#!/usr/bin/env ruby

# HELP functionz [<name>]; list all available utility functions, optionally list only a specific doc

def echo_help_text(path)
    tail = File.basename(path)
    found = false
    File.open(path, "r") do |file|
        regexr_match = file.find { |line| line =~ /#\sHELP\s(.+)/ }
        found = !regexr_match.to_s.strip.empty?
        found ? puts("\033[0;31m%s\033[0m -> %s" % [tail, $1]) : nil
    end
    found ? nil : puts("\033[0;31m%s\033[0m" % tail)
end

# ruby is an unholy language
#  im torn, i do not know if this is disgusting or really cool
def dir_contents(dir)
    files = Dir.entries(File.dirname(dir)).sort().select{ |fn| ! fn.include? "."}
    output_lines = []
    for fn in files do
        path = "%s/%s" % [File.dirname(dir), fn]
        next unless File.file?(path)
        tail = File.basename(path)
        found = false
        File.open(path, "r") do |file|
            regexr_match = file.find { |line| line =~ /#\sHELP\s(.+)/ }
            found = !regexr_match.to_s.strip.empty?
            if found
                output_lines << "\033[0;31m%s\033[0m -> %s" % [tail, $1]
            else
                output_lines << "\033[0;31m%s\033[0m" % tail
            end
        end
    end

    page_output(output_lines)
end

def terminal_height
    begin
        require 'io/console'
        IO.console.winsize[0]
    rescue
        25  # default fallback
    end
end

def terminal_width
    begin
        require 'io/console'
        IO.console.winsize[1]
    rescue
        80  # default fallback
    end
end

def strip_ansi_codes(text)
    text.gsub(/\033\[[0-9;]*m/, '')
end

def calculate_wrapped_lines(lines)
    width = terminal_width
    total_lines = 0

    lines.each do |line|
        clean_line = strip_ansi_codes(line)
        if clean_line.length <= width
            total_lines += 1
        else
            total_lines += (clean_line.length.to_f / width).ceil
        end
    end

    total_lines
end

def page_output(output_lines)
    # Check if output should be paged
    if $stdout.isatty && calculate_wrapped_lines(output_lines) > terminal_height - 2
        # Use pager for output
        IO.popen("less -R", "w") do |pager|
            output_lines.each { |line| pager.puts line }
        end
    else
        output_lines.each { |line| puts line }
    end
end

if __FILE__ == $0
    if ARGV.length > 1
      puts "functionz [<name>]; list all available utility functions, optionally list only a specific doc"
      exit(2)
    end

    if ARGV.length == 1
        # glob the argument and return all matches
        globbed_path = Dir.glob("%s/*%s*" % [File.dirname(__FILE__), ARGV[0]])
        if globbed_path.empty?
            abort("Function '%s' does not exist!" % [ ARGV[0] ])
            exit(1)
        end

        output_lines = []
        globbed_path.each do |fn|
            tail = File.basename(fn)
            found = false
            File.open(fn, "r") do |file|
                regexr_match = file.find { |line| line =~ /#\sHELP\s(.+)/ }
                found = !regexr_match.to_s.strip.empty?
                if found
                    output_lines << "\033[0;31m%s\033[0m -> %s" % [tail, $1]
                else
                    output_lines << "\033[0;31m%s\033[0m" % tail
                end
            end
        end

        page_output(output_lines)
        exit()
    end
    dir_contents(__FILE__)
end
